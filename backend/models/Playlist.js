const mongoose = require('mongoose');

const playlistSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Playlist name is required'],
    trim: true,
    maxlength: [100, 'Playlist name cannot exceed 100 characters']
  },
  description: {
    type: String,
    maxlength: [500, 'Description cannot exceed 500 characters'],
    trim: true
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Playlist owner is required']
  },
  media: [{
    mediaId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Media',
      required: true
    },
    addedAt: {
      type: Date,
      default: Date.now
    },
    addedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    position: {
      type: Number,
      required: true
    }
  }],
  coverImage: {
    type: String, // URL to cover image
    default: null
  },
  isPublic: {
    type: Boolean,
    default: false
  },
  isCollaborative: {
    type: Boolean,
    default: false
  },
  collaborators: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    permissions: {
      canAdd: {
        type: Boolean,
        default: true
      },
      canRemove: {
        type: Boolean,
        default: false
      },
      canReorder: {
        type: Boolean,
        default: false
      },
      canEdit: {
        type: Boolean,
        default: false
      }
    },
    addedAt: {
      type: Date,
      default: Date.now
    }
  }],
  followers: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  tags: [{
    type: String,
    trim: true,
    maxlength: [30, 'Tag cannot exceed 30 characters']
  }],
  genre: {
    type: String,
    trim: true,
    maxlength: [50, 'Genre cannot exceed 50 characters']
  },
  mood: {
    type: String,
    enum: ['happy', 'sad', 'energetic', 'calm', 'romantic', 'aggressive', 'melancholic', 'uplifting', 'party', 'workout'],
    lowercase: true
  },
  stats: {
    playCount: {
      type: Number,
      default: 0
    },
    likeCount: {
      type: Number,
      default: 0
    },
    shareCount: {
      type: Number,
      default: 0
    },
    followCount: {
      type: Number,
      default: 0
    },
    lastPlayed: Date
  },
  isActive: {
    type: Boolean,
    default: true
  },
  isFeatured: {
    type: Boolean,
    default: false
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  autoGenerationRules: {
    genre: [String],
    artist: [String],
    mood: [String],
    maxDuration: Number, // in seconds
    maxTracks: Number,
    includeExplicit: {
      type: Boolean,
      default: true
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for total duration
playlistSchema.virtual('totalDuration').get(function() {
  return this.populated('media.mediaId') 
    ? this.media.reduce((total, item) => total + (item.mediaId.duration || 0), 0)
    : 0;
});

// Virtual for formatted total duration
playlistSchema.virtual('formattedTotalDuration').get(function() {
  const totalSeconds = this.totalDuration;
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
});

// Virtual for track count
playlistSchema.virtual('trackCount').get(function() {
  return this.media.length;
});

// Indexes for better query performance
playlistSchema.index({ owner: 1 });
playlistSchema.index({ isPublic: 1 });
playlistSchema.index({ isFeatured: 1 });
playlistSchema.index({ tags: 1 });
playlistSchema.index({ genre: 1 });
playlistSchema.index({ mood: 1 });
playlistSchema.index({ createdAt: -1 });
playlistSchema.index({ 'stats.playCount': -1 });
playlistSchema.index({ 'stats.likeCount': -1 });
playlistSchema.index({ 'stats.followCount': -1 });

// Text search index
playlistSchema.index({
  name: 'text',
  description: 'text',
  tags: 'text'
});

// Pre-save middleware
playlistSchema.pre('save', function(next) {
  // Ensure tags are unique and lowercase
  if (this.tags) {
    this.tags = [...new Set(this.tags.map(tag => tag.toLowerCase()))];
  }
  
  // Update follower count
  this.stats.followCount = this.followers.length;
  
  next();
});

// Instance methods
playlistSchema.methods.addMedia = function(mediaId, userId, position) {
  // If position not specified, add to end
  if (position === undefined) {
    position = this.media.length;
  }
  
  // Check if media already exists
  const existingIndex = this.media.findIndex(item => item.mediaId.equals(mediaId));
  if (existingIndex !== -1) {
    throw new Error('Media already exists in playlist');
  }
  
  // Adjust positions of existing items if inserting in middle
  if (position < this.media.length) {
    this.media.forEach(item => {
      if (item.position >= position) {
        item.position += 1;
      }
    });
  }
  
  this.media.push({
    mediaId,
    addedBy: userId,
    position,
    addedAt: new Date()
  });
  
  // Sort by position
  this.media.sort((a, b) => a.position - b.position);
  
  return this.save();
};

playlistSchema.methods.removeMedia = function(mediaId) {
  const index = this.media.findIndex(item => item.mediaId.equals(mediaId));
  if (index === -1) {
    throw new Error('Media not found in playlist');
  }
  
  const removedPosition = this.media[index].position;
  this.media.splice(index, 1);
  
  // Adjust positions of remaining items
  this.media.forEach(item => {
    if (item.position > removedPosition) {
      item.position -= 1;
    }
  });
  
  return this.save();
};

playlistSchema.methods.reorderMedia = function(mediaId, newPosition) {
  const index = this.media.findIndex(item => item.mediaId.equals(mediaId));
  if (index === -1) {
    throw new Error('Media not found in playlist');
  }
  
  const oldPosition = this.media[index].position;
  
  if (oldPosition === newPosition) {
    return this; // No change needed
  }
  
  // Update positions
  this.media.forEach(item => {
    if (oldPosition < newPosition) {
      // Moving down
      if (item.position > oldPosition && item.position <= newPosition) {
        item.position -= 1;
      }
    } else {
      // Moving up
      if (item.position >= newPosition && item.position < oldPosition) {
        item.position += 1;
      }
    }
  });
  
  this.media[index].position = newPosition;
  
  // Sort by position
  this.media.sort((a, b) => a.position - b.position);
  
  return this.save();
};

playlistSchema.methods.addCollaborator = function(userId, permissions = {}) {
  // Check if user is already a collaborator
  const existingIndex = this.collaborators.findIndex(collab => collab.user.equals(userId));
  if (existingIndex !== -1) {
    throw new Error('User is already a collaborator');
  }
  
  this.collaborators.push({
    user: userId,
    permissions: {
      canAdd: permissions.canAdd !== undefined ? permissions.canAdd : true,
      canRemove: permissions.canRemove !== undefined ? permissions.canRemove : false,
      canReorder: permissions.canReorder !== undefined ? permissions.canReorder : false,
      canEdit: permissions.canEdit !== undefined ? permissions.canEdit : false
    }
  });
  
  return this.save();
};

playlistSchema.methods.removeCollaborator = function(userId) {
  const index = this.collaborators.findIndex(collab => collab.user.equals(userId));
  if (index === -1) {
    throw new Error('User is not a collaborator');
  }
  
  this.collaborators.splice(index, 1);
  return this.save();
};

playlistSchema.methods.toggleFollow = function(userId) {
  const index = this.followers.indexOf(userId);
  if (index > -1) {
    this.followers.splice(index, 1);
  } else {
    this.followers.push(userId);
  }
  return this.save();
};

playlistSchema.methods.incrementPlayCount = function() {
  this.stats.playCount += 1;
  this.stats.lastPlayed = new Date();
  return this.save();
};

playlistSchema.methods.incrementLikeCount = function() {
  this.stats.likeCount += 1;
  return this.save();
};

playlistSchema.methods.decrementLikeCount = function() {
  this.stats.likeCount = Math.max(0, this.stats.likeCount - 1);
  return this.save();
};

playlistSchema.methods.incrementShareCount = function() {
  this.stats.shareCount += 1;
  return this.save();
};

// Static methods
playlistSchema.statics.findPublic = function(options = {}) {
  const { limit = 20, skip = 0, sortBy = 'createdAt', sortOrder = -1 } = options;
  
  return this.find({ isPublic: true, isActive: true })
    .sort({ [sortBy]: sortOrder })
    .limit(limit)
    .skip(skip)
    .populate('owner', 'username avatar')
    .populate('media.mediaId', 'title artist duration thumbnailUrl');
};

playlistSchema.statics.findFeatured = function(limit = 10) {
  return this.find({ isFeatured: true, isPublic: true, isActive: true })
    .sort({ 'stats.playCount': -1, 'stats.followCount': -1 })
    .limit(limit)
    .populate('owner', 'username avatar')
    .populate('media.mediaId', 'title artist duration thumbnailUrl');
};

playlistSchema.statics.searchPlaylists = function(query, options = {}) {
  const { limit = 20, skip = 0, sortBy = 'createdAt', sortOrder = -1 } = options;

  return this.find({
    $text: { $search: query },
    isPublic: true,
    isActive: true
  })
    .sort({ [sortBy]: sortOrder })
    .limit(limit)
    .skip(skip)
    .populate('owner', 'username avatar')
    .populate('media.mediaId', 'title artist duration thumbnailUrl');
};

playlistSchema.statics.getTrending = function(days = 7, limit = 20) {
  const dateThreshold = new Date();
  dateThreshold.setDate(dateThreshold.getDate() - days);

  return this.find({
    isPublic: true,
    isActive: true,
    'stats.lastPlayed': { $gte: dateThreshold }
  })
    .sort({ 'stats.playCount': -1, 'stats.followCount': -1 })
    .limit(limit)
    .populate('owner', 'username avatar')
    .populate('media.mediaId', 'title artist duration thumbnailUrl');
};

module.exports = mongoose.model('Playlist', playlistSchema);

